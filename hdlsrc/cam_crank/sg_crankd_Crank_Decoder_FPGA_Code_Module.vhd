-- -------------------------------------------------------------
-- 
-- File Name: tmp_vhdl\crank_decoder_fpga_module\sg_crankd_Crank_Decoder_FPGA_Code_Module.vhd
-- 
-- Generated by MATLAB 9.6 and HDL Coder 3.14
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1.33333e-08
-- Target subsystem base rate: 1.33333e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1.33333e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- current_tooth                 ce_out        1.33333e-08
-- crank_period                  ce_out        1.33333e-08
-- version                       ce_out        1.33333e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: sg_crankd_Crank_Decoder_FPGA_Code_Module
-- Source Path: crank_decoder_fpga_module/Crank Decoder FPGA Code Module
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY sg_crankd_Crank_Decoder_FPGA_Code_Module IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        enable                            :   IN    std_logic;
        number_of_crank_teeth             :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        number_of_crank_missing_teeth     :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        Invert_Crankshaft                 :   IN    std_logic;
        crankshaft                        :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        current_tooth                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        crank_period                      :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        version                           :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END sg_crankd_Crank_Decoder_FPGA_Code_Module;


ARCHITECTURE rtl OF sg_crankd_Crank_Decoder_FPGA_Code_Module IS

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Unit_Delay4_reg                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Unit_Delay4_out1                 : std_logic;
  SIGNAL Bitwise_Operator1_out1           : std_logic;
  SIGNAL Switch_out1                      : std_logic;
  SIGNAL U_k_1                            : std_logic;
  SIGNAL FixPt_Relational_Operator_relop1 : std_logic;
  SIGNAL Bitwise_Operator_out1            : std_logic;
  SIGNAL U_k_1_1                          : std_logic;
  SIGNAL FixPt_Relational_Operator1_relop1 : std_logic;
  SIGNAL Unit_Delay_Enabled_Synchronous_out1 : std_logic;
  SIGNAL Crank_Period_Length_out1         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Unit_Delay_Enabled_Synchronous1_out1 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bitwise_AND_out1                 : std_logic;
  SIGNAL Unit_Delay_Enabled_Synchronous1_out1_1 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Gain_out1                        : unsigned(63 DOWNTO 0);  -- ufix64_En31
  SIGNAL Relational_Operator_1_cast       : unsigned(63 DOWNTO 0);  -- ufix64_En31
  SIGNAL Relational_Operator_relop1       : std_logic;
  SIGNAL U_k_1_2                          : std_logic;
  SIGNAL FixPt_Relational_Operator2_relop1 : std_logic;
  SIGNAL FixPt_Relational_Operator_out1   : std_logic;
  SIGNAL HDL_Counter2_out1                : std_logic;  -- ufix1
  SIGNAL Bitwise_NOT_out1                 : std_logic;  -- ufix1
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL Unit_Delay_out1                  : std_logic;
  SIGNAL HDL_Counter_out1                 : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Constant1_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Add_op_stage2                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL number_of_crank_teeth_unsigned   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Add_op_stage3                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL Add_out1                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Add_out1_dtc                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Switch_out1_1                    : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Unit_Delay_Enabled_Resettable_Synchronous_out1 : std_logic;
  SIGNAL Bitwise_NOT1_out1                : std_logic;
  SIGNAL Bitwise_AND_out1_1               : std_logic;
  SIGNAL Unit_Delay_Enabled_Synchronous3_out1 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL constant_out1                    : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Base_Address_out1                : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice_out1                   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Major_Version_out1               : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Minor_Version_out1               : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Bit_Concat_out1                  : unsigned(31 DOWNTO 0);  -- uint32

BEGIN
  -- To-do:
  -- Check if the crank is synchronized (the missing teeth event matches with the missing teeth locations)
  -- 
  -- % Comment
  -- We output the Current Teeth (HDL Counter) only when the index has been found once.
  -- 
  -- This index is found when a missing teeth is detected and when the current teeth counter matches with the position 
  -- of a missing teet
  -- 
  -- Edge
  -- 
  -- U(k)
  -- 
  -- Edge
  -- 
  -- U(k)
  -- 
  -- Edge
  -- 
  -- U(k)

  enb <= clk_enable;

  
  switch_compare_1 <= '1' WHEN Invert_Crankshaft > '0' ELSE
      '0';

  Unit_Delay4_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Unit_Delay4_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        Unit_Delay4_reg(0) <= crankshaft;
        Unit_Delay4_reg(1) <= Unit_Delay4_reg(0);
      END IF;
    END IF;
  END PROCESS Unit_Delay4_process;

  Unit_Delay4_out1 <= Unit_Delay4_reg(1);

  Bitwise_Operator1_out1 <=  NOT Unit_Delay4_out1;

  
  Switch_out1 <= Unit_Delay4_out1 WHEN switch_compare_1 = '0' ELSE
      Bitwise_Operator1_out1;

  -- 
  -- Store in Global RAM
  Delay_Input1_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        U_k_1 <= '0';
      ELSIF enb = '1' THEN
        U_k_1 <= Switch_out1;
      END IF;
    END IF;
  END PROCESS Delay_Input1_process;


  
  FixPt_Relational_Operator_relop1 <= '1' WHEN Switch_out1 > U_k_1 ELSE
      '0';

  Bitwise_Operator_out1 <= FixPt_Relational_Operator_relop1 AND enable;

  -- 
  -- Store in Global RAM
  Delay_Input11_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        U_k_1_1 <= '0';
      ELSIF enb = '1' THEN
        U_k_1_1 <= Bitwise_Operator_out1;
      END IF;
    END IF;
  END PROCESS Delay_Input11_process;


  
  FixPt_Relational_Operator1_relop1 <= '1' WHEN Bitwise_Operator_out1 > U_k_1_1 ELSE
      '0';

  Unit_Delay_Enabled_Synchronous_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Unit_Delay_Enabled_Synchronous_out1 <= '0';
      ELSIF enb = '1' AND FixPt_Relational_Operator1_relop1 = '1' THEN
        Unit_Delay_Enabled_Synchronous_out1 <= FixPt_Relational_Operator1_relop1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous_process;


  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  Crank_Period_Length_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Crank_Period_Length_out1 <= to_unsigned(0, 32);
      ELSIF enb = '1' THEN
        IF Bitwise_Operator_out1 = '1' THEN 
          Crank_Period_Length_out1 <= to_unsigned(0, 32);
        ELSIF Unit_Delay_Enabled_Synchronous_out1 = '1' THEN 
          Crank_Period_Length_out1 <= Crank_Period_Length_out1 + to_unsigned(1, 32);
        END IF;
      END IF;
    END IF;
  END PROCESS Crank_Period_Length_process;


  Unit_Delay_Enabled_Synchronous1_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Unit_Delay_Enabled_Synchronous1_out1 <= to_unsigned(0, 32);
      ELSIF enb = '1' AND Bitwise_Operator_out1 = '1' THEN
        Unit_Delay_Enabled_Synchronous1_out1 <= Crank_Period_Length_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous1_process;


  Bitwise_AND_out1 <= Unit_Delay_Enabled_Synchronous_out1 AND FixPt_Relational_Operator1_relop1;

  Unit_Delay_Enabled_Synchronous11_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Unit_Delay_Enabled_Synchronous1_out1_1 <= to_unsigned(0, 32);
      ELSIF enb = '1' AND Bitwise_AND_out1 = '1' THEN
        Unit_Delay_Enabled_Synchronous1_out1_1 <= Unit_Delay_Enabled_Synchronous1_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous11_process;


  Gain_out1 <= unsigned'(X"C0000000") * Unit_Delay_Enabled_Synchronous1_out1_1;

  Relational_Operator_1_cast <= resize(Unit_Delay_Enabled_Synchronous1_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 64);
  
  Relational_Operator_relop1 <= '1' WHEN Relational_Operator_1_cast > Gain_out1 ELSE
      '0';

  -- 
  -- Store in Global RAM
  Delay_Input12_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        U_k_1_2 <= '0';
      ELSIF enb = '1' THEN
        U_k_1_2 <= Relational_Operator_relop1;
      END IF;
    END IF;
  END PROCESS Delay_Input12_process;


  
  FixPt_Relational_Operator2_relop1 <= '1' WHEN Relational_Operator_relop1 > U_k_1_2 ELSE
      '0';

  FixPt_Relational_Operator_out1 <= FixPt_Relational_Operator2_relop1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  HDL_Counter2_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        HDL_Counter2_out1 <= '0';
      ELSIF enb = '1' AND FixPt_Relational_Operator_out1 = '1' THEN
        HDL_Counter2_out1 <=  NOT HDL_Counter2_out1;
      END IF;
    END IF;
  END PROCESS HDL_Counter2_process;


  Bitwise_NOT_out1 <=  NOT HDL_Counter2_out1;

  
  switch_compare_1_1 <= '1' WHEN Bitwise_NOT_out1 > '0' ELSE
      '0';

  Unit_Delay_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Unit_Delay_out1 <= '0';
      ELSIF enb = '1' THEN
        Unit_Delay_out1 <= Bitwise_AND_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_process;


  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  HDL_Counter_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        HDL_Counter_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        IF Relational_Operator_relop1 = '1' THEN 
          HDL_Counter_out1 <= to_unsigned(16#0000#, 16);
        ELSIF Unit_Delay_out1 = '1' THEN 
          HDL_Counter_out1 <= HDL_Counter_out1 + to_unsigned(16#0001#, 16);
        END IF;
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  Constant1_out1 <= to_unsigned(0, 32);

  Add_op_stage2 <= resize(HDL_Counter_out1, 32) + Constant1_out1;

  number_of_crank_teeth_unsigned <= unsigned(number_of_crank_teeth);

  Add_op_stage3 <= Add_op_stage2 + number_of_crank_teeth_unsigned;

  Add_out1 <= Add_op_stage3 - Constant1_out1;

  Add_out1_dtc <= Add_out1(15 DOWNTO 0);

  
  Switch_out1_1 <= HDL_Counter_out1 WHEN switch_compare_1_1 = '0' ELSE
      Add_out1_dtc;

  current_tooth <= std_logic_vector(Switch_out1_1);

  Unit_Delay_Enabled_Resettable_Synchronous_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Unit_Delay_Enabled_Resettable_Synchronous_out1 <= '0';
      ELSIF enb = '1' THEN
        IF Bitwise_AND_out1 = '1' THEN
          Unit_Delay_Enabled_Resettable_Synchronous_out1 <= '0';
        ELSIF Relational_Operator_relop1 = '1' THEN
          Unit_Delay_Enabled_Resettable_Synchronous_out1 <= Relational_Operator_relop1;
        END IF;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Resettable_Synchronous_process;


  Bitwise_NOT1_out1 <=  NOT Unit_Delay_Enabled_Resettable_Synchronous_out1;

  Bitwise_AND_out1_1 <= Bitwise_NOT1_out1 AND Bitwise_AND_out1;

  Unit_Delay_Enabled_Synchronous3_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN
        Unit_Delay_Enabled_Synchronous3_out1 <= to_unsigned(0, 32);
      ELSIF enb = '1' AND Bitwise_AND_out1_1 = '1' THEN
        Unit_Delay_Enabled_Synchronous3_out1 <= Unit_Delay_Enabled_Synchronous1_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous3_process;


  crank_period <= std_logic_vector(Unit_Delay_Enabled_Synchronous3_out1);

  constant_out1 <= to_unsigned(16#2#, 2);

  Base_Address_out1 <= to_unsigned(1130496, 32);

  Bit_Slice_out1 <= Base_Address_out1(23 DOWNTO 14);

  Major_Version_out1 <= to_unsigned(16#003#, 10);

  Minor_Version_out1 <= to_unsigned(16#002#, 10);

  Bit_Concat_out1 <= constant_out1 & Bit_Slice_out1 & Major_Version_out1 & Minor_Version_out1;

  version <= std_logic_vector(Bit_Concat_out1);

  ce_out <= clk_enable;

END rtl;

