-- -------------------------------------------------------------
-- 
-- File Name: tmp_vhdl\ssim_fpga_code_module\sg_ssim_SSI_Master_FPGA_Code_Module.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 0.048
-- Target subsystem base rate: 0.048
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: sg_ssim_SSI_Master_FPGA_Code_Module
-- Source Path: ssim_fpga_code_module/SSI Master FPGA Code Module
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.sg_ssim_SSI_Master_FPGA_Code_Module_pkg.ALL;

ENTITY sg_ssim_SSI_Master_FPGA_Code_Module IS
  PORT( clk_i                             :   IN    std_logic;
        reset_i                           :   IN    std_logic;
        Clock_Divider                     :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        Number_of_Bits                    :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        Time_Pause                        :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        Time_Low                          :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        start                             :   IN    std_logic;
        SDI                               :   IN    std_logic;
        Version                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        SCK                               :   OUT   std_logic;
        RX_Valid                          :   OUT   std_logic;
        RX_Word                           :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END sg_ssim_SSI_Master_FPGA_Code_Module;


ARCHITECTURE rtl OF sg_ssim_SSI_Master_FPGA_Code_Module IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL Bit_Slice_out1                   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Bit_Concat_out1                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Number_of_Bits_unsigned          : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Data_Type_Conversion_out1        : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL Clock_Divider_unsigned           : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum_out1                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Unit_Delay_out1                  : std_logic := '0';
  SIGNAL Time_Pause_unsigned              : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Time_Low_unsigned                : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL idle                             : std_logic;
  SIGNAL tl                               : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL tp                               : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL clkDiv                           : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL rx_nxt                           : std_logic;
  SIGNAL rx_nxt_1                         : std_logic;
  SIGNAL rx_run                           : std_logic;
  SIGNAL rx_run_1                         : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL Bit_Counter_out1                 : unsigned(5 DOWNTO 0) := to_unsigned(16#00#, 6);  -- ufix6
  SIGNAL Compare_To_Constant_out1_1       : std_logic;
  SIGNAL start_1                          : std_logic;
  SIGNAL is_Chart                         : T_state_type_is_Chart;  -- uint8
  SIGNAL SCK_1                            : std_logic;
  SIGNAL ChartMode                        : T_ChartModeType;  -- enum type ChartModeType (12 enums)
  SIGNAL is_finally_Chart                 : T_ChartModeType;  -- enum type ChartModeType (12 enums)
  SIGNAL temporalCounter_i1               : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL Unit_Delay2_out1                 : std_logic;
  SIGNAL U_k                              : std_logic;
  SIGNAL U_k_1                            : std_logic := '0';
  SIGNAL FixPt_Relational_Operator_relop1 : std_logic;
  SIGNAL Unit_Delay_out1_1                : std_logic := '0';
  SIGNAL Unit_Delay_out1_2                : std_logic;
  SIGNAL Unit_Delay1_out1                 : std_logic;
  SIGNAL Unit_Delay_Enabled_Resettable_Synchronous_out1 : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL Bit_Shift_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum_out1_1                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Unit_Delay_Enabled_Synchronous_out1 : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32

BEGIN
  -- Edge
  -- 
  -- U(k)

  Bit_Slice_out1 <= to_unsigned(16#00F#, 10);

  Bit_Concat_out1 <= "10" & (Bit_Slice_out1 & unsigned'("0000000010" & "0000000101"));

  Version <= std_logic_vector(Bit_Concat_out1);

  Number_of_Bits_unsigned <= unsigned(Number_of_Bits);

  Data_Type_Conversion_out1 <= Number_of_Bits_unsigned(5 DOWNTO 0);

  Clock_Divider_unsigned <= unsigned(Clock_Divider);

  Sum_out1 <= Clock_Divider_unsigned - to_unsigned(1, 32);

  
  Compare_To_Constant_out1 <= '1' WHEN Clock_Divider_unsigned > to_unsigned(0, 32) ELSE
      '0';

  Unit_Delay_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      Unit_Delay_out1 <= Compare_To_Constant_out1;
    END IF;
  END PROCESS Unit_Delay_process;


  Time_Pause_unsigned <= unsigned(Time_Pause);

  Time_Low_unsigned <= unsigned(Time_Low);

  Unit_Delay_Enabled_Synchronous1_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF idle = '1' THEN
        tl <= Time_Low_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous1_process;


  Unit_Delay_Enabled_Synchronous2_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF idle = '1' THEN
        tp <= Time_Pause_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous2_process;


  Unit_Delay_Enabled_Synchronous_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF idle = '1' THEN
        clkDiv <= Sum_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous_process;


  rx_nxt_1 <= rx_nxt;

  rx_run_1 <= rx_run;

  Logical_Operator_out1 <=  NOT rx_run_1;

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = -1
  Bit_Counter_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF Logical_Operator_out1 = '1' THEN 
        Bit_Counter_out1 <= Data_Type_Conversion_out1;
      ELSIF rx_nxt_1 = '1' THEN 
        Bit_Counter_out1 <= Bit_Counter_out1 + to_unsigned(16#3F#, 6);
      END IF;
    END IF;
  END PROCESS Bit_Counter_process;


  
  Compare_To_Constant_out1_1 <= '1' WHEN Bit_Counter_out1 = to_unsigned(16#00#, 6) ELSE
      '0';

  start_1 <= start AND idle;

  -- compensate for SCK_SYMM and NEXT_BIT
  -- for the 1st clock cycle
  --
  Chart_process : PROCESS (clk_i)
    VARIABLE sf_internal_predicateOutput : std_logic;
    VARIABLE guard1 : std_logic;
    VARIABLE temporalCounter_i1_temp : unsigned(31 DOWNTO 0);
    VARIABLE is_Chart_temp : T_state_type_is_Chart;
    VARIABLE is_finally_Chart_temp : T_ChartModeType;
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        temporalCounter_i1 <= to_unsigned(0, 32);
        is_Chart <= IN_x_IDLE;
        is_finally_Chart <= x_IDLE;
      ELSE 
        sf_internal_predicateOutput := '0';
        is_Chart_temp := is_Chart;
        is_finally_Chart_temp := is_finally_Chart;
        temporalCounter_i1_temp := temporalCounter_i1;
        IF temporalCounter_i1 < unsigned'("11111111111111111111111111111111") THEN 
          temporalCounter_i1_temp := temporalCounter_i1 + to_unsigned(1, 32);
        END IF;
        guard1 := '0';
        CASE is_Chart IS
          WHEN IN_sNEXT_BIT =>
            is_Chart_temp := IN_sSCK_HIGH;
            temporalCounter_i1_temp := to_unsigned(0, 32);
            is_finally_Chart_temp := sSCK_HIGH;
          WHEN IN_sSCK_1st_high =>
            is_Chart_temp := IN_sSCK_HIGH;
            temporalCounter_i1_temp := to_unsigned(0, 32);
            is_finally_Chart_temp := sSCK_HIGH;
          WHEN IN_sSCK_1st_low =>
            is_Chart_temp := IN_sSCK_1st_high;
            is_finally_Chart_temp := sSCK_1st_high;
          WHEN IN_sSCK_HIGH =>
            IF Compare_To_Constant_out1_1 = '1' THEN 
              IF tl = to_unsigned(0, 32) THEN 
                is_Chart_temp := IN_sTP;
                temporalCounter_i1_temp := to_unsigned(0, 32);
                is_finally_Chart_temp := sTP;
              ELSIF temporalCounter_i1_temp >= clkDiv THEN 
                is_Chart_temp := IN_sTL_LOW;
                temporalCounter_i1_temp := to_unsigned(0, 32);
                is_finally_Chart_temp := sTL_LOW;
              ELSE 
                guard1 := '1';
              END IF;
            ELSE 
              guard1 := '1';
            END IF;
          WHEN IN_sSCK_LOW =>
            IF temporalCounter_i1_temp >= clkDiv THEN 
              is_Chart_temp := IN_sNEXT_BIT;
              is_finally_Chart_temp := sNEXT_BIT;
            END IF;
          WHEN IN_sSCK_SYMM =>
            is_Chart_temp := IN_sSCK_LOW;
            temporalCounter_i1_temp := to_unsigned(0, 32);
            is_finally_Chart_temp := sSCK_LOW;
          WHEN IN_sTL =>
            IF temporalCounter_i1_temp >= tl THEN 
              is_Chart_temp := IN_sTP;
              temporalCounter_i1_temp := to_unsigned(0, 32);
              is_finally_Chart_temp := sTP;
            END IF;
          WHEN IN_sTL_LOW =>
            IF temporalCounter_i1_temp >= clkDiv THEN 
              is_Chart_temp := IN_sTL;
              temporalCounter_i1_temp := to_unsigned(0, 32);
              is_finally_Chart_temp := sTL;
            END IF;
          WHEN IN_sTP =>
            IF temporalCounter_i1_temp >= tp THEN 
              is_Chart_temp := IN_x_IDLE;
              is_finally_Chart_temp := x_IDLE;
            END IF;
          WHEN IN_sTX_START =>
            IF temporalCounter_i1_temp >= clkDiv THEN 
              is_Chart_temp := IN_sSCK_1st_low;
              is_finally_Chart_temp := sSCK_1st_low;
            END IF;
          WHEN OTHERS => 
            --case IN_x_IDLE:
            sf_internal_predicateOutput := hdlcoder_to_stdlogic((start_1 AND Unit_Delay_out1) = '1');
            IF sf_internal_predicateOutput = '1' THEN 
              is_Chart_temp := IN_sTX_START;
              temporalCounter_i1_temp := to_unsigned(0, 32);
              is_finally_Chart_temp := sTX_START;
            END IF;
        END CASE;
        IF guard1 = '1' THEN 
          IF temporalCounter_i1_temp >= clkDiv THEN 
            is_Chart_temp := IN_sSCK_SYMM;
            is_finally_Chart_temp := sSCK_SYMM;
          END IF;
        END IF;
        is_Chart <= is_Chart_temp;
        is_finally_Chart <= is_finally_Chart_temp;
        temporalCounter_i1 <= temporalCounter_i1_temp;
      END IF;
    END IF;
  END PROCESS Chart_process;

  Chart_output : PROCESS (is_Chart, is_finally_Chart)
    VARIABLE idle1 : std_logic;
    VARIABLE rx_run1 : std_logic;
    VARIABLE rx_nxt1 : std_logic;
    VARIABLE SCK1 : std_logic;
  BEGIN
    idle1 := '0';
    rx_run1 := '0';
    rx_nxt1 := '0';
    SCK1 := '1';
    CASE is_Chart IS
      WHEN IN_sNEXT_BIT =>
        rx_nxt1 := '1';
        rx_run1 := '1';
      WHEN IN_sSCK_1st_high =>
        rx_run1 := '1';
      WHEN IN_sSCK_1st_low =>
        SCK1 := '0';
        rx_run1 := '1';
      WHEN IN_sSCK_HIGH =>
        rx_run1 := '1';
      WHEN IN_sSCK_LOW =>
        SCK1 := '0';
        rx_run1 := '1';
      WHEN IN_sSCK_SYMM =>
        SCK1 := '0';
        rx_run1 := '1';
      WHEN IN_sTL =>
        SCK1 := '0';
      WHEN IN_sTL_LOW =>
        SCK1 := '0';
      WHEN IN_sTP =>
        NULL;
      WHEN IN_sTX_START =>
        SCK1 := '0';
        rx_run1 := '1';
      WHEN OTHERS => 
        --case IN_x_IDLE:
        idle1 := '1';
    END CASE;
    ChartMode <= is_finally_Chart;
    SCK_1 <= SCK1;
    idle <= idle1;
    rx_nxt <= rx_nxt1;
    rx_run <= rx_run1;
  END PROCESS Chart_output;


  Unit_Delay21_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        Unit_Delay2_out1 <= '1';
      ELSE 
        Unit_Delay2_out1 <= SCK_1;
      END IF;
    END IF;
  END PROCESS Unit_Delay21_process;


  
  U_k <= '1' WHEN Compare_To_Constant_out1_1 > '0' ELSE
      '0';

  -- 
  -- Store in Global RAM
  Delay_Input1_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      U_k_1 <= U_k;
    END IF;
  END PROCESS Delay_Input1_process;


  
  FixPt_Relational_Operator_relop1 <= '1' WHEN U_k > U_k_1 ELSE
      '0';

  Unit_Delay1_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      Unit_Delay_out1_1 <= FixPt_Relational_Operator_relop1;
    END IF;
  END PROCESS Unit_Delay1_process;


  Unit_Delay2_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        Unit_Delay_out1_2 <= '1';
      ELSE 
        Unit_Delay_out1_2 <= SDI;
      END IF;
    END IF;
  END PROCESS Unit_Delay2_process;


  Unit_Delay11_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        Unit_Delay1_out1 <= '1';
      ELSE 
        Unit_Delay1_out1 <= Unit_Delay_out1_2;
      END IF;
    END IF;
  END PROCESS Unit_Delay11_process;


  Bit_Shift_out1 <= Unit_Delay_Enabled_Resettable_Synchronous_out1 sll 1;

  Sum_out1_1 <= Bit_Shift_out1 + ('0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & Unit_Delay1_out1);

  Unit_Delay_Enabled_Resettable_Synchronous_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF Logical_Operator_out1 = '1' THEN
        Unit_Delay_Enabled_Resettable_Synchronous_out1 <= to_unsigned(0, 32);
      ELSIF rx_nxt_1 = '1' THEN
        Unit_Delay_Enabled_Resettable_Synchronous_out1 <= Sum_out1_1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Resettable_Synchronous_process;


  Unit_Delay_Enabled_Synchronous3_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF FixPt_Relational_Operator_relop1 = '1' THEN
        Unit_Delay_Enabled_Synchronous_out1 <= Unit_Delay_Enabled_Resettable_Synchronous_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous3_process;


  RX_Word <= std_logic_vector(Unit_Delay_Enabled_Synchronous_out1);

  SCK <= Unit_Delay2_out1;

  RX_Valid <= Unit_Delay_out1_1;

END rtl;

