-- -------------------------------------------------------------
-- 
-- File Name: tmp_vhdl\ssis_fpga_code_module\sg_ssis_SSI_Slave_FPGA_Code_Module.vhd
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 0.2
-- Target subsystem base rate: 0.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: sg_ssis_SSI_Slave_FPGA_Code_Module
-- Source Path: ssis_fpga_code_module/SSI Slave FPGA Code Module
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.sg_ssis_SSI_Slave_FPGA_Code_Module_pkg.ALL;

ENTITY sg_ssis_SSI_Slave_FPGA_Code_Module IS
  PORT( clk_i                             :   IN    std_logic;
        reset_i                           :   IN    std_logic;
        Number_of_Bits                    :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        Transfer_Timeout                  :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        Clock_Timeout                     :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        TX_Data                           :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        SCK                               :   IN    std_logic;
        Version                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        SDO                               :   OUT   std_logic
        );
END sg_ssis_SSI_Slave_FPGA_Code_Module;


ARCHITECTURE rtl OF sg_ssis_SSI_Slave_FPGA_Code_Module IS

  -- Signals
  SIGNAL Bit_Slice_out1                   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Bit_Concat_out1                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Unit_Delay_out1                  : std_logic;
  SIGNAL Unit_Delay1_out1                 : std_logic;
  SIGNAL Unit_Delay1_out1_1               : std_logic := '0';
  SIGNAL FixPt_Relational_Operator_relop1 : std_logic;
  SIGNAL sck_re                           : std_logic;
  SIGNAL FixPt_Relational_Operator1_relop1 : std_logic;
  SIGNAL Transfer_Timeout_unsigned        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Clock_Timeout_unsigned           : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Number_of_Bits_unsigned          : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Data_Type_Conversion_out1        : signed(6 DOWNTO 0);  -- sfix7
  SIGNAL tx_run                           : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL load_shiftreg                    : std_logic;
  SIGNAL Bit_Counter_out1                 : signed(6 DOWNTO 0) := to_signed(16#00#, 7);  -- sfix7
  SIGNAL idle                             : std_logic;
  SIGNAL tc                               : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL tm                               : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL HDL_Counter_out1                 : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL is_Control                       : T_state_type_is_Control;  -- uint8
  SIGNAL sdo_state_1                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL ControlMode_1                    : T_ControlModeType;  -- enum type ControlModeType (5 enums)
  SIGNAL temporalCounter_i1               : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL Logical_Operator_out1_1          : std_logic;
  SIGNAL TX_Data_unsigned                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Unit_Delay_Enabled_Synchronous2_out1 : unsigned(31 DOWNTO 0) := to_unsigned(0, 32);  -- uint32
  SIGNAL Unit_Delay_Enabled_Synchronous_out1 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Shift_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Switch_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice_out1_1                 : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion_out1_1      : std_logic;
  SIGNAL Multiport_Switch_out1            : std_logic;
  SIGNAL U_k_1                            : std_logic;
  SIGNAL U_k_1_1                          : std_logic;

BEGIN
  -- Edge
  -- 
  -- U(k)
  -- 
  -- Edge
  -- 
  -- U(k)

  Bit_Slice_out1 <= to_unsigned(16#02D#, 10);

  Bit_Concat_out1 <= "10" & (Bit_Slice_out1 & unsigned'("0000000010" & "0000000011"));

  Version <= std_logic_vector(Bit_Concat_out1);

  Unit_Delay_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        Unit_Delay_out1 <= '1';
      ELSE 
        Unit_Delay_out1 <= SCK;
      END IF;
    END IF;
  END PROCESS Unit_Delay_process;


  Unit_Delay1_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        Unit_Delay1_out1 <= '1';
      ELSE 
        Unit_Delay1_out1 <= Unit_Delay_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay1_process;


  -- 
  -- Store in Global RAM
  -- 
  -- 
  -- Store in Global RAM
  reduced_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      Unit_Delay1_out1_1 <= Unit_Delay1_out1;
    END IF;
  END PROCESS reduced_process;


  
  FixPt_Relational_Operator_relop1 <= '1' WHEN Unit_Delay1_out1 > Unit_Delay1_out1_1 ELSE
      '0';

  sck_re <= FixPt_Relational_Operator_relop1;

  
  FixPt_Relational_Operator1_relop1 <= '1' WHEN Unit_Delay1_out1 < Unit_Delay1_out1_1 ELSE
      '0';

  Transfer_Timeout_unsigned <= unsigned(Transfer_Timeout);

  Clock_Timeout_unsigned <= unsigned(Clock_Timeout);

  Number_of_Bits_unsigned <= unsigned(Number_of_Bits);

  Data_Type_Conversion_out1 <= signed(Number_of_Bits_unsigned(6 DOWNTO 0));

  Logical_Operator_out1 <= sck_re AND tx_run;

  -- Free running, Signed Counter
  --  initial value   = 0
  --  step value      = -1
  Bit_Counter_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF load_shiftreg = '1' THEN 
        Bit_Counter_out1 <= Data_Type_Conversion_out1;
      ELSIF Logical_Operator_out1 = '1' THEN 
        Bit_Counter_out1 <= Bit_Counter_out1 + to_signed(-16#01#, 7);
      END IF;
    END IF;
  END PROCESS Bit_Counter_process;


  
  tx_run <= '1' WHEN Bit_Counter_out1 > to_signed(16#00#, 7) ELSE
      '0';

  Unit_Delay_Enabled_Synchronous11_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF idle = '1' THEN
        tc <= Clock_Timeout_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous11_process;


  Unit_Delay_Enabled_Synchronous1_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF idle = '1' THEN
        tm <= Transfer_Timeout_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous1_process;


  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = -1
  HDL_Counter_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF FixPt_Relational_Operator1_relop1 = '1' THEN 
        HDL_Counter_out1 <= tm;
      ELSIF Compare_To_Constant_out1 = '1' THEN 
        HDL_Counter_out1 <= HDL_Counter_out1 + unsigned'(X"FFFFFFFF");
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  
  Compare_To_Constant_out1 <= '1' WHEN HDL_Counter_out1 > to_unsigned(0, 32) ELSE
      '0';

  -- It appears, as the states are translated into the VHDL case in alphabetical order.
  -- To ensure that idle will be the OTHERS clause, the prefix X_ has been added
  --
  Control_process : PROCESS (clk_i)
    VARIABLE temporalCounter_i1_temp : unsigned(31 DOWNTO 0);
    VARIABLE is_Control_temp : T_state_type_is_Control;
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        temporalCounter_i1 <= to_unsigned(0, 32);
        is_Control <= IN_xIDLE;
      ELSE 
        is_Control_temp := is_Control;
        temporalCounter_i1_temp := temporalCounter_i1;
        IF temporalCounter_i1 < unsigned'("11111111111111111111111111111111") THEN 
          temporalCounter_i1_temp := temporalCounter_i1 + to_unsigned(1, 32);
        END IF;
        CASE is_Control IS
          WHEN IN_sCLR_CLKTMO =>
            IF ( NOT tx_run) = '1' THEN 
              is_Control_temp := IN_sTRANSFER_TIMEOUT;
            ELSE 
              is_Control_temp := IN_sTRANSFER;
              temporalCounter_i1_temp := to_unsigned(0, 32);
            END IF;
          WHEN IN_sTRANSFER =>
            IF ( NOT tx_run) = '1' THEN 
              is_Control_temp := IN_sTRANSFER_TIMEOUT;
            ELSIF temporalCounter_i1_temp >= tc THEN 
              is_Control_temp := IN_xIDLE;
            ELSIF sck_re = '1' THEN 
              is_Control_temp := IN_sCLR_CLKTMO;
            END IF;
          WHEN IN_sTRANSFER_TIMEOUT =>
            IF sck_re = '1' THEN 
              is_Control_temp := IN_sTRANSFER;
              temporalCounter_i1_temp := to_unsigned(0, 32);
            ELSIF ( NOT Compare_To_Constant_out1) = '1' THEN 
              is_Control_temp := IN_xIDLE;
            END IF;
          WHEN OTHERS => 
            --case IN_xIDLE:
            IF sck_re = '1' THEN 
              is_Control_temp := IN_sTRANSFER;
              temporalCounter_i1_temp := to_unsigned(0, 32);
            END IF;
        END CASE;
        is_Control <= is_Control_temp;
        temporalCounter_i1 <= temporalCounter_i1_temp;
      END IF;
    END IF;
  END PROCESS Control_process;

  Control_output : PROCESS (is_Control)
    VARIABLE idle1 : std_logic;
    VARIABLE sdo_state : unsigned(1 DOWNTO 0);
    VARIABLE load_shiftreg1 : std_logic;
    VARIABLE ControlMode : T_ControlModeType;
  BEGIN
    idle1 := '0';
    load_shiftreg1 := '0';
    CASE is_Control IS
      WHEN IN_sCLR_CLKTMO =>
        ControlMode := sCLR_CLKTMO;
        sdo_state := to_unsigned(16#1#, 2);
      WHEN IN_sTRANSFER =>
        ControlMode := sTRANSFER;
        sdo_state := to_unsigned(16#1#, 2);
      WHEN IN_sTRANSFER_TIMEOUT =>
        ControlMode := sTRANSFER_TIMEOUT;
        load_shiftreg1 := '1';
        sdo_state := to_unsigned(16#2#, 2);
      WHEN OTHERS => 
        --case IN_xIDLE:
        ControlMode := xIDLE;
        load_shiftreg1 := '1';
        sdo_state := to_unsigned(16#3#, 2);
        idle1 := '1';
    END CASE;
    ControlMode_1 <= ControlMode;
    idle <= idle1;
    load_shiftreg <= load_shiftreg1;
    sdo_state_1 <= sdo_state;
  END PROCESS Control_output;


  Logical_Operator_out1_1 <= sck_re OR load_shiftreg;

  TX_Data_unsigned <= unsigned(TX_Data);

  Unit_Delay_Enabled_Synchronous2_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF idle = '1' THEN
        Unit_Delay_Enabled_Synchronous2_out1 <= TX_Data_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous2_process;


  Bit_Shift_out1 <= Unit_Delay_Enabled_Synchronous_out1 sll 1;

  
  Switch_out1 <= Bit_Shift_out1 WHEN load_shiftreg = '0' ELSE
      Unit_Delay_Enabled_Synchronous2_out1;

  Unit_Delay_Enabled_Synchronous_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        Unit_Delay_Enabled_Synchronous_out1 <= to_unsigned(1, 32);
      ELSE 
        IF Logical_Operator_out1_1 = '1' THEN
          Unit_Delay_Enabled_Synchronous_out1 <= Switch_out1;
        END IF;
      END IF;
    END IF;
  END PROCESS Unit_Delay_Enabled_Synchronous_process;


  Bit_Slice_out1_1 <= Unit_Delay_Enabled_Synchronous_out1(31);

  
  Data_Type_Conversion_out1_1 <= '1' WHEN Bit_Slice_out1_1 /= '0' ELSE
      '0';

  
  Multiport_Switch_out1 <= Data_Type_Conversion_out1_1 WHEN sdo_state_1 = to_unsigned(16#1#, 2) ELSE
      '0' WHEN sdo_state_1 = to_unsigned(16#2#, 2) ELSE
      '1';

  Unit_Delay2_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF reset_i = '1' THEN
        SDO <= '1';
      ELSE 
        SDO <= Multiport_Switch_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay2_process;


END rtl;

